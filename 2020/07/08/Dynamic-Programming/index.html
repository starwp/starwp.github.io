<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="article">
<meta property="og:title" content="Dynamic Programming">
<meta property="og:url" content="https://starwp.github.io/2020/07/08/Dynamic-Programming/index.html">
<meta property="og:site_name" content="Make It Happen">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://miro.medium.com/max/684/0*3dS6Jw8NzzSD-mn8.jpg">
<meta property="og:image" content="https://www.mathworks.com/matlabcentral/mlc-downloads/downloads/submissions/67486/versions/1/screenshot.png">
<meta property="og:image" content="https://starwp.github.io/2020/07/08/Dynamic-Programming/image-20200721180707241.png">
<meta property="og:image" content="https://starwp.github.io/2020/07/08/Dynamic-Programming/image-20200721183427683.png">
<meta property="og:image" content="https://starwp.github.io/2020/07/08/Dynamic-Programming/image-20200721180235085.png">
<meta property="article:published_time" content="2020-07-09T01:38:47.000Z">
<meta property="article:modified_time" content="2020-07-30T03:21:00.943Z">
<meta property="article:author" content="Void Spirit">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://miro.medium.com/max/684/0*3dS6Jw8NzzSD-mn8.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://starwp.github.io/2020/07/08/Dynamic-Programming/"/>





  <title>Dynamic Programming | Make It Happen</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Make It Happen</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://starwp.github.io/2020/07/08/Dynamic-Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Void Spirit">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Make It Happen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Dynamic Programming</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-08T21:38:47-04:00">
                2020-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column"  style="width: 50%;"><img src="https://miro.medium.com/max/684/0*3dS6Jw8NzzSD-mn8.jpg" class="" width="400"></div><div class="group-picture-column"  style="width: 50%;"><img src="https://www.mathworks.com/matlabcentral/mlc-downloads/downloads/submissions/67486/versions/1/screenshot.png" class="" width="250"></div></div><div class="group-picture-row"></div></div></div>







<a id="more"></a>

<h1 id="Knapsack-Problems"><a href="#Knapsack-Problems" class="headerlink" title="Knapsack Problems"></a>Knapsack Problems</h1><p>The following discussion foucus on the series of knapsack problems.</p>
<h2 id="Problem-1-Basic-Version"><a href="#Problem-1-Basic-Version" class="headerlink" title="Problem 1: Basic Version"></a>Problem 1: Basic Version</h2><p>Given <em>n</em> items with size Ai, an integer <em>m</em> denotes the size of a backpack, find the maximum size we can fit.</p>
<p>We can solve the problem based on the last step induction method. That is, the last item is either considered in the maximum size or not. Additionaly, the size should be a key. Hence, we get the recurrence quation as follows:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][w] = max(dp[i<span class="number">-1</span>][w], dp[i<span class="number">-1</span>][w-A[w]] + A[w])</span><br></pre></td></tr></table></figure>

<p>where dp[i][w] is defined as <strong>the maximum size we can fit by using the first i items and a backpack with the size of w</strong>. </p>
<p><img src="image-20200721180707241.png" alt="image-20200721180707241"></p>
<p>Then, the code is shown</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack_I</span><span class="params">(A, m)</span>:</span></span><br><span class="line">    dp = collections.defaultdict(int)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">            dp[i%<span class="number">2</span>,j] = dp[(i<span class="number">-1</span>)%<span class="number">2</span>,j]</span><br><span class="line">            <span class="keyword">if</span> j &gt;= A[i]: </span><br><span class="line">                dp[i%<span class="number">2</span>,j] = max(dp[i%<span class="number">2</span>,j], dp[(i<span class="number">-1</span>)%<span class="number">2</span>,j-A[i]] + A[i])</span><br><span class="line">    <span class="keyword">return</span> dp[(len(A)<span class="number">-1</span>)%<span class="number">2</span>, m]</span><br></pre></td></tr></table></figure>

<ul>
<li>Notice that since we define that dp[i][w] associates with w and the index j represents the size, we should loop j in <span style="color:red"><strong>[0, m]</strong></span>. </li>
</ul>
<h2 id="Problem-2-General-Version"><a href="#Problem-2-General-Version" class="headerlink" title="Problem 2: General Version"></a>Problem 2: General Version</h2><p>Given <code>n</code> items and a backpack with size <code>m</code>. Given array <code>A</code> representing the size of each item and array <code>V</code> representing the value of each item. What’s the maximum value can you put into the backpack?</p>
<p>This one is similar to the basic version.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack_II</span><span class="params">(A, V, m)</span>:</span>        </span><br><span class="line">    dp = [[<span class="number">0</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)] </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            dp[i%<span class="number">2</span>][j] = dp[(i<span class="number">-1</span>)%<span class="number">2</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j &gt;= A[i]:</span><br><span class="line">                dp[i%<span class="number">2</span>][j] = max(dp[i%<span class="number">2</span>][j], dp[(i<span class="number">-1</span>)%<span class="number">2</span>][j-A[i]] + V[i])</span><br><span class="line">    <span class="keyword">return</span> dp[(len(A)<span class="number">-1</span>)%<span class="number">2</span>][m]</span><br></pre></td></tr></table></figure>



<h2 id="Problem-3-Unbounded-Version"><a href="#Problem-3-Unbounded-Version" class="headerlink" title="Problem 3: Unbounded Version"></a>Problem 3: Unbounded Version</h2><p>Given <code>n</code> items and a backpack with size <code>m</code>. Given array <code>A</code> representing the size of each item and array <code>V</code> representing the value of each item. What’s the maximum value can you put into the backpack? (Each item has infinite number available)</p>
<h3 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h3><p>Since the problem changes to the unlimited version, from the last step perspective, we consider all the items in the array in the last step</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[w] = max(dp[w<span class="number">-1</span>], dp[w-A[i] + V[i]] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)) <span class="keyword">if</span> w &gt;= A[i])</span><br></pre></td></tr></table></figure>

<p>where the defintion dp[i][w] represents that <strong>the maximum value obtained by using any kind of items with unliminted times to achieve the given target w</strong>. </p>
<p><img src="image-20200721183427683.png" alt="image-20200721183427683"></p>
<p>Therefore, the code is shown as</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack_III</span><span class="params">(A, V, m)</span>:</span>        </span><br><span class="line">    dp = [<span class="number">0</span>] * (m + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        dp[w] = dp[w<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        	<span class="keyword">if</span> w &gt;= A[i]:</span><br><span class="line">            	dp[w] = max(dp[w], dp[w-A[i]] + V[i])</span><br><span class="line">    <span class="keyword">return</span> dp[m]</span><br></pre></td></tr></table></figure>



<h3 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h3><p>Since for any item, we might use <strong>different times</strong>. Assuming that we use it <strong>k</strong> times. Thus, the recurrence equation is shown that:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][w] = max(dp[i<span class="number">-1</span>][w-k*A[i]] + k*V[i] <span class="keyword">for</span> k <span class="keyword">in</span> range(large_number) <span class="keyword">if</span> w &gt;= k*A[i])</span><br></pre></td></tr></table></figure>

<p>where the defintion dp[i][w] represents that <strong>the maximum value obtained by using first i items with unlimited times to achieve the given target w</strong>. However, the problem in above recurrence equation is that the parameter k increases the time complexity. Fortunately, we observe an interesting point that is </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][w-A[i]] = max(dp[i<span class="number">-1</span>][w-(k+<span class="number">1</span>)*A[i]] + k*V[i] <span class="keyword">for</span> k <span class="keyword">in</span> range(large_number) <span class="keyword">if</span> w &gt;= k*A[i])</span><br></pre></td></tr></table></figure>

<p>with the equation above, the recurrence equation can be transfomed to </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][w] = max(dp[i<span class="number">-1</span>][w], dp[i][w-A[i]] + V[i])</span><br></pre></td></tr></table></figure>

<p><img src="image-20200721180235085.png" alt="image-20200721180235085"></p>
<p>Thus, the code is shown as </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack_III</span><span class="params">(A, V, m)</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (m + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> w &gt;= A[i]:</span><br><span class="line">                dp[w] = max(dp[w], dp[w-A[i]] + V[i])</span><br><span class="line">    <span class="keyword">return</span> dp[m]</span><br></pre></td></tr></table></figure>





<h2 id="Problem-4-Combination-Version"><a href="#Problem-4-Combination-Version" class="headerlink" title="Problem 4: Combination Version"></a>Problem 4: Combination Version</h2><p>Given n items with size <code>A[i]</code> which an integer array and all positive numbers. An integer <code>target</code> denotes the size of a backpack. Find the number of possible fill the backpack. Each item may only be used once.</p>
<p>As we consider the number of solutions in this problem, so the recurrence equation becomes</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][w] = dp[i<span class="number">-1</span>][w] + dp[i<span class="number">-1</span>][w-A[i]] <span class="comment"># w &gt;= A[i]</span></span><br></pre></td></tr></table></figure>

<p>where the defintion dp[i][w] represents that <strong>the number of ways obtained by using the first i items to achieve the given target w</strong>. Therefore, the code is shown as</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack_IV</span><span class="params">(A, target)</span>        </span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">sum</span><span class="params">(A)</span> &lt; <span class="title">target</span>:</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (target + <span class="number">1</span>), [<span class="number">1</span>] + [<span class="number">0</span>] * target]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">            dp[i%<span class="number">2</span>][j] = dp[(i<span class="number">-1</span>)%<span class="number">2</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j &gt;= A[i]:</span><br><span class="line">                dp[i%<span class="number">2</span>][j] += dp[(i<span class="number">-1</span>)%<span class="number">2</span>][j-A[i]]  </span><br><span class="line">    <span class="keyword">return</span> dp[(len(A)<span class="number">-1</span>)%<span class="number">2</span>][target]</span><br></pre></td></tr></table></figure>

<ul>
<li>Notice that the initial condition for this problem is that </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">-1</span>][<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># initial condition</span></span><br></pre></td></tr></table></figure>

<p>This means using no items to obtain the target 0 is exactly one possible way.</p>
<h2 id="Problem-5-Unbounded-Combination-Version"><a href="#Problem-5-Unbounded-Combination-Version" class="headerlink" title="Problem 5: Unbounded Combination Version"></a>Problem 5: Unbounded Combination Version</h2><p>Given an integer array <code>A</code> which contains <code>n</code> unique positive numbers, <code>A[i]</code> indicate the size of <code>i</code>th item. An integer <code>target</code> denotes the size of backpack. Find the number of ways to fill the backpack. Each item may be chosen unlimited number of times. </p>
<p>Based on <strong>Method 2 of Problem 3</strong>,  we design the following recurrence equation</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][w] = dp[i<span class="number">-1</span>][w] + dp[i][w-A[i]]</span><br></pre></td></tr></table></figure>

<p>where dp[w] represents *<em>the number of combinations to achive the target w by using the first i items with unlimited times *</em> . Thus, the code is shown as</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack_V</span><span class="params">(A, target)</span>:</span></span><br><span class="line">    dp = [<span class="number">1</span>] + [<span class="number">0</span>] * target</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">        	<span class="keyword">if</span> w &gt;= A[i]:</span><br><span class="line">            	dp[w] += dp[w-A[i]]</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure>





<h2 id="Problem-6-Unbounded-Permutation-Version"><a href="#Problem-6-Unbounded-Permutation-Version" class="headerlink" title="Problem 6: Unbounded Permutation Version"></a>Problem 6: Unbounded Permutation Version</h2><p>Given an integer array <code>A</code> with all positive numbers and no duplicates, find the number of permutations that add up to a positve integer target. </p>
<p>eg. A=[1, 2, 4], target = 4. The solution [1,2,1] and [2,1,1] are considered different.</p>
<p>Based on <strong>Method 1 of Problem 3</strong>, we only consider the last step</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[w] = sum(dp[w-A[i]] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)) <span class="keyword">if</span> w &gt;= A[i])</span><br></pre></td></tr></table></figure>

<p>where dp[w] represents <strong>the number of permutations to achive the target w by using any kind of items with unlimited times</strong>. Thus, the code is shown as</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack_VI</span><span class="params">(A, target)</span>:</span></span><br><span class="line">    dp = [<span class="number">1</span>] + [<span class="number">0</span>] * target</span><br><span class="line">	<span class="keyword">for</span> w <span class="keyword">in</span> range(<span class="number">1</span> + target):</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">			<span class="keyword">if</span> w &gt;= A[i]:</span><br><span class="line">				dp[w] += dp[w-A[i]]</span><br><span class="line">	<span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure>









<h2 id="Thoughts-on-the-Knapsack-Problem"><a href="#Thoughts-on-the-Knapsack-Problem" class="headerlink" title="Thoughts on the Knapsack Problem"></a>Thoughts on the Knapsack Problem</h2><p>Today, I did the target sum problem, where I learned two ways to solve the problem.</p>
<ol>
<li>Pull: </li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][sum] = dp[i<span class="number">-1</span>][sum - A[i]] + dp[i<span class="number">-1</span>][sum + A[i]]</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>Push:</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][sum + A[i]] += dp[i][sum]</span><br><span class="line">dp[i][sum - A[i]] += dp[i][sum]</span><br></pre></td></tr></table></figure>



<p>It is interesting to use push to solve the problem. In addition, we can use the dictionary to lower the search space in the initial stages.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> A:</span><br><span class="line">    tmp = collections.defaultdict(int)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> dp:</span><br><span class="line">        tmp[key + e] += dp[key]</span><br><span class="line">        tmp[key - e] += dp[key]</span><br><span class="line">    dp = tmp</span><br><span class="line"><span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure>



<p>However, more interesting thing is that we don’t need to do the minus part by considering the following reduction. As it holds that </p>
<p>P - N = Target</p>
<p>P - N + P + N = Target + Sum(A)</p>
<p>P = (T + Sum) / 2</p>
<p>where P is a set of positive integers and N is the set of negative integers. </p>
<p>So the problem can be transformed to a subset sum problem to find a target sum at (T + Sum) / 2, by using this condition, we further pruning the search. </p>
<h1 id="Partitioned-DP"><a href="#Partitioned-DP" class="headerlink" title="Partitioned DP"></a>Partitioned DP</h1><p>This partitioned DP requires deals with a string or sequence, where we might need to partition the string into k substrings (subsequence) and each of them satisfies different condition.</p>
<h2 id="Problem-1-Palindrome-Partitioning"><a href="#Problem-1-Palindrome-Partitioning" class="headerlink" title="Problem 1: Palindrome Partitioning"></a>Problem 1: Palindrome Partitioning</h2><p>Given a string <code>s</code>, cut <code>s</code> into some substrings such that every substring is a palindrome. Return the <strong>minimum</strong> cuts needed for a palindrome partitioning of <em>s</em>.</p>
<p>Based on the last step principle, we can define dp[i] as the min-cut obtained by the string with the first i elements. Therefore, we could have the recurrence</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = min(dp[i], dp[j] + <span class="number">1</span> <span class="keyword">if</span> isPalindrome(s[i:j+<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>

<p>This indicates that we need to store the result of that whether every string s[i:j+1] is a palindrome or not. Then, we need O(n^2) space. </p>
<p>To shrink the space complexity, a good technique is to apply <strong>push</strong>, then we can decide if a substring is a palindrome and store its results while updating the dp values. Thus, the push technique shows the recurrence as follows </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i+r] = min(dp[i+r], dp[i-r<span class="number">-1</span>] + <span class="number">1</span>) <span class="comment"># </span></span><br><span class="line">dp[i+r+<span class="number">1</span>] = min(dp[i+r+<span class="number">1</span>], dp[i-r<span class="number">-1</span>] + <span class="number">1</span>) <span class="comment"># one is for odd palindrome, another is for even case</span></span><br></pre></td></tr></table></figure>

<p>where r represents the “radius” of the substring s[i-r, i+r].</p>
<h2 id="Problem-2-Copy-Books"><a href="#Problem-2-Copy-Books" class="headerlink" title="Problem 2: Copy Books"></a>Problem 2: Copy Books</h2><p>Given <code>n</code> books and the <code>i-th</code> book has <code>pages[i]</code> pages. There are <code>k</code> persons to copy these books. These books list in a row and each person can claim a continous range of books. For example, one copier can copy the books from <code>i-th</code> to <code>j-th</code> continously, but he can not copy the 1st book, 2nd book and 4th book (without 3rd book). They start copying books at the same time and they all cost 1 minute to copy 1 page of a book. What’s the best strategy to assign books so that the slowest copier can finish at earliest time? Return the shortest time that the slowest copier spends.</p>
<p>Given this partitioned one, we can use the previously similar last step principle.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[k][i] = min(max(dp[k<span class="number">-1</span>][j], sum(pages[j:i]) <span class="keyword">for</span> j <span class="keyword">in</span> range(i))</span><br></pre></td></tr></table></figure>

<p>where dp[i] as the shortest time using by k workers with the first i books.</p>
<p>The abve recurrence equation also requires to deal with the summation in advance to lower the time complexity.</p>
<ul>
<li>Notice that sometimes based on the last step princeple, we might need to do additional computation to do the comparing, which probably could be done in advance and stored the results to lower the time complexity. <span style="color:red"><strong>(extra computation, comparing, do it ahead to store them)</strong></span>. </li>
</ul>
<h1 id="Interval-DP"><a href="#Interval-DP" class="headerlink" title="Interval DP"></a>Interval DP</h1><p>The interval Dp is almost the most difficult problem in DP. Different from the traditional DP by using the last step principle, the last step principle most of the time fails to work it out in the polynomial time. If we do some DP problem and find out the last step does not work, it is in a big chance that we need to consider the interval DP, where we partition the problem into small pieces by 2D index.</p>
<p>To be specific, the last step principle uses dp[i] with 1D index, where i is the last step. However, the interval dp typically uses dp[i][j] with 2D index, where i is the first step and j is the last step. It is kind of like divide and conquer. <span style="color:red"><strong>(2D index, dp[start][end])</strong></span>. </p>
<h2 id="Problem-1-Balloon-Burst"><a href="#Problem-1-Balloon-Burst" class="headerlink" title="Problem 1: Balloon Burst"></a>Problem 1: Balloon Burst</h2><h1 id="Game-Theory-DP"><a href="#Game-Theory-DP" class="headerlink" title="Game Theory DP"></a>Game Theory DP</h1><p> The geme theory dp problem deals with two playes with the optimal policy. So, we generally need to consider the two players together and solve the recurrence in a reversed manner.</p>
<h2 id="Problem-1-Stone-III"><a href="#Problem-1-Stone-III" class="headerlink" title="Problem 1: Stone III"></a>Problem 1: Stone III</h2><p>Based on the last step principle, we define dp[i] to be the max relative value player got by using the first i </p>
<h1 id="Double-Sequence-DP"><a href="#Double-Sequence-DP" class="headerlink" title="Double Sequence DP"></a>Double Sequence DP</h1><p>The double sequence DP is typicall defined as a problem where the objective depends on a given property based on the two sequences. For example, consider a problem P. There are two sequences A and B to deal with based on an objective (find largest common subsequences, transform A to B in the minimal step, and whether B is a substring of A and so on). Typically, based on the last step, we define dp[i][j] which is the max/min value to solve the problem. </p>
<p>To derivate the recurrence equation, we utilize the pull method. Firstly and most importantly, assuming <span style="color:red"><strong>the objective with first i in A and first j in B has already been achieved</strong></span> now with the min/max value of dp[i][j]. For simplicity, we say <span style="color:red"><strong>the setting of dp[i][j] is achieved</strong></span>. For instance, with dp[i][j], we assume we have found the longest common subsequence or we have transfomred A to B now. Based on this achieved objective, we <span style="color:red"><strong>reason backward</strong></span> that how to get dp[i][j] and <span style="color:red"><strong>what the possible step in in the last step to achieve dp[i][j] and its setting</strong></span>. This generally should be related to dp[i-1][j], dp[i][j-1], or dp[i-1][j-1].  </p>
<p>An important point is that <span style="color:red"><strong>even the setting of dp[i][j] is considered</strong></span>, like the practical scenario (dealing with A[0:i] and B[0:j] might change them to the setting A’[0:x], B’[0:y] based on the given objective), the recurrence to be built is always focusing on the orignial strings and index <span style="color:red"><strong>(A[i-1], B[j-1]), (A[i], B[j-1]), (A[i],B[j-1])</strong></span> rather than those settings ((A’[0:x-1], B’[0:y-1]), A’[0:x], B’[0:y-1]). </p>
<h2 id="Problem-1-Edit-Distance"><a href="#Problem-1-Edit-Distance" class="headerlink" title="Problem 1: Edit Distance"></a>Problem 1: Edit Distance</h2><p>Given two words <em>A</em> and <em>B</em>, find the minimum number of steps required to convert A to B. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word:</p>
<ul>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ul>
<p>Since the covertion requires the permutation, we can define that dp[i][j] is the min step that we convert A[i] to B[j]. Based on the discussion above, by reasoning backward, the possible step to achieve the conversion is to either insert at pos i, delete the pos i, or replace the pos i. Hence, the recurrence equation is derivated as </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min(dp[i][j<span class="number">-1</span>] + <span class="number">1</span>,  \ <span class="comment"># insert after pos i  </span></span><br><span class="line">               dp[i<span class="number">-1</span>][j] + <span class="number">1</span>,  \ <span class="comment"># delete the pos i</span></span><br><span class="line">               dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>,\ <span class="comment"># replace the pos i</span></span><br><span class="line">			   dp[i<span class="number">-1</span>][j<span class="number">-1</span>])\ <span class="comment"># no operation A[i] = B[j]</span></span><br></pre></td></tr></table></figure>

<p>where the above cases are discussed:</p>
<ul>
<li>Case 1: inserting at pos i indicates in the problem dp[i][j] the new element insert after A[i] matches B[j], so that 1st recurrence holds. </li>
<li>Case 2: deleting at pos i indicates in the problem dp[i][j] A[i] is extra element and takes the extra step, so 2nd case holds</li>
<li>Case 3: replacing, easily understood</li>
<li>Case 4: no operation, easily understood. </li>
</ul>
<h2 id="Problem-2-Longest-Increasing-Common-Subsequence"><a href="#Problem-2-Longest-Increasing-Common-Subsequence" class="headerlink" title="Problem 2: Longest Increasing Common Subsequence"></a>Problem 2: Longest Increasing Common Subsequence</h2><p>Given 2 sequences of integers, we need to find a longest sub-sequence which is common to both the sequences, and the numbers of such a sub-sequence are in strictly increasing order.</p>
<p>Let dp[i][j] be the LICS of A[0:i] and B[0:j]. Based on the last step principle, consider the following cases:</p>
<ul>
<li>Case 1: B[j-1] is not in LICS, dp[i][j] = dp[i][j-1]</li>
<li>Case 2: A[i-1] is not in the LICS, dp[i][j] = dp[i-1][j]</li>
<li>Case 3: A[i-1] and B[j-1] are both in LICS, dp[i][j] = dp[i-1][j-1] + 1, where A[i-1] = B[j-1] and A[i-1] is larger than the last value in the setting of dp[i-1][j-1]. (missing some cases…)</li>
</ul>
<p>Notice that the difficulty in Case 3 is that we need to know the last value in the previous setting dp[i-1][j-1], which is in fact unknown. To solve the problem, I use the following technique 1. </p>
<h3 id="technique-1"><a href="#technique-1" class="headerlink" title="technique 1:"></a>technique 1:</h3><p><span style="color:red"><strong>If the information is unknown, compute it by introducing dp[i][j][1].</strong></span></p>
<p>Based on the technique, we extend the defintion dp[i][j] to target both the maximal length LICS and the samllest ending number in the LICS.</p>
<ul>
<li>dp[i][j][0]: maximal length of LICS</li>
<li>dp[i][j][1]: smallest ending number of this LICS</li>
</ul>
<p>Thus, we go back to previos discussion.</p>
<ul>
<li>Case 1: dp[i][j][0] = dp[i][j-1][0], dp[i][j][1] = dp[i][j-1][1]</li>
<li>Case 2: dp[i][j][0] = dp[i-1][j][0], dp[i][j][1] = dp[i-1][j][1] </li>
<li>Case 3: dp[i][j][0] = dp[i-1][j-1][0] + 1 if A[i-1] = B[j-1] and A[i-1] &gt; dp[i-1][j-1][1], dp[i][j][1] = A[i-1]</li>
</ul>
<p>However, something is overlooked in Case 3. For A[i-1] = B[j-1], we need to update the dp[i][j] by comparing all the previously dp[i-1][0]…dp[i-1][j-1] to find the LICS, so we modify Case 3 to:</p>
<ul>
<li>Case 3: dp[i][j][0] =  max(dp[i][j][0], dp[i-1][k][0] + 1) if A[i-1] = B[j-1] and A[i-1] &gt; dp[i-1][k][1], for k in range(j-1).</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LICS</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    dp = collections.defaultdict(int)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(B)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[i, j, <span class="number">0</span>], dp[i, j, <span class="number">1</span>] = <span class="number">0</span>, sys.maxsize</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">            dp[i,j,<span class="number">1</span>] = sys.maxsize</span><br><span class="line">            <span class="keyword">if</span> A[i<span class="number">-1</span>] == B[j<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, j+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> A[i<span class="number">-1</span>] &gt; dp[i<span class="number">-1</span>,k<span class="number">-1</span>,<span class="number">1</span>] <span class="keyword">or</span> dp[i<span class="number">-1</span>,k<span class="number">-1</span>,<span class="number">1</span>] == sys.maxsize <span class="keyword">and</span> \</span><br><span class="line">                        dp[i,j,<span class="number">0</span>] &lt;= dp[i<span class="number">-1</span>,k<span class="number">-1</span>,<span class="number">0</span>] + <span class="number">1</span>:</span><br><span class="line">                            dp[i,j,<span class="number">1</span>], dp[i,j,<span class="number">0</span>] = A[i<span class="number">-1</span>], dp[i<span class="number">-1</span>,k<span class="number">-1</span>,<span class="number">0</span>] + <span class="number">1</span>            </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> dp[i,j,<span class="number">0</span>] &lt;= dp[i,j<span class="number">-1</span>,<span class="number">0</span>]:</span><br><span class="line">                dp[i,j,<span class="number">1</span>] = min(dp[i,j,<span class="number">1</span>], dp[i,j<span class="number">-1</span>,<span class="number">1</span>]) <span class="keyword">if</span> dp[i,j,<span class="number">0</span>] == dp[i,j<span class="number">-1</span>,<span class="number">0</span>] <span class="keyword">else</span> dp[i,j<span class="number">-1</span>,<span class="number">1</span>] </span><br><span class="line">                dp[i,j,<span class="number">0</span>] = dp[i,j<span class="number">-1</span>,<span class="number">0</span>]</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> dp[i,j,<span class="number">0</span>] &lt;= dp[i<span class="number">-1</span>,j,<span class="number">0</span>]:</span><br><span class="line">                dp[i,j,<span class="number">1</span>] = min(dp[i,j,<span class="number">1</span>], dp[i<span class="number">-1</span>,j,<span class="number">1</span>]) <span class="keyword">if</span> dp[i,j,<span class="number">0</span>] == dp[i<span class="number">-1</span>,j,<span class="number">0</span>] <span class="keyword">else</span> dp[i<span class="number">-1</span>,j,<span class="number">1</span>]</span><br><span class="line">                dp[i,j,<span class="number">0</span>] = dp[i<span class="number">-1</span>,j,<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> dp[len(A), len(B), <span class="number">0</span>]</span><br></pre></td></tr></table></figure>



<p>Based on the above logic, it is a O(n^3) time algorithm. In addtion, the logic is a little complicated due to we introduce the last value in the LICS. Thus, In the following we use the 2nd technique to solve it. </p>
<h3 id="technique-2"><a href="#technique-2" class="headerlink" title="technique 2:"></a>technique 2:</h3><p><span style="color:red"><strong>If the information is unknown, associating it with the index in dp[i][j].</strong></span></p>
<p>Based on this technique, it is obvious that we need to associate the last value of LICS of the index of dp[i][j]. Therefore, we redefine dp[i][j] to be the LICS of A[0:i] and B[0:j] where B[j-1] is the last value in this LICS. Therefore, the following recurrence can be derived easily.</p>
<ul>
<li>Case 1: dp[i][j] = max(dp[i][j], dp[i-1][j] if A[i-1] != B[j-1])</li>
<li>Case 2: dp[i][j] = max(dp[i][j], dp[i-1][k] if A[i-1] == B[j-1] and B[j-1] &gt; B[k] for k in range(j))</li>
</ul>
<p>With the above recurrence equation, we are able to clearly solve the problem in O(n^3) time. However, there are some space for us to improve it. That is, since A[i-1] = B[j-1] and B[j-1] is the largest value, we need to find maximal of all the dp[i-1][k] with B[k] smaller than A[j-1],</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LICS</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(len(B))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        max_i_minus_one = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(B)):</span><br><span class="line">            <span class="keyword">if</span> A[i] == B[j]:</span><br><span class="line">                dp[j] = max(dp[j], max_i_minus_one + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> A[i] &gt; B[j]:</span><br><span class="line">                max_i_minus_one = max(dp[j], max_i_minus_one)</span><br><span class="line">    <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>



<p>Therefore, the above algorithm is O(n^2) time with O(n) space.</p>
<h1 id="Hard-Problems"><a href="#Hard-Problems" class="headerlink" title="Hard Problems"></a>Hard Problems</h1><p>This sections presents some hard problems and discusses the important thoughts on solviing them.</p>
<h2 id="Problem-1-Minimum-Adjustment-Cost"><a href="#Problem-1-Minimum-Adjustment-Cost" class="headerlink" title="Problem 1: Minimum Adjustment Cost"></a>Problem 1: Minimum Adjustment Cost</h2><p>To solve this problem, we start with the last step principle. We thus define dp[i] as the min-cost of adjustment for first i integers. Based on this defintion, we assume that A[i] is changed to B[i], where it holds that |B[i]- B[i-1]| &lt; target. </p>
<p>So, there are two important questions to answer. </p>
<ul>
<li>B[i-1] is unknow</li>
<li>Even it is known, how can we guarantee it is <strong>optimal</strong> to modify A[i] to B[i] within [B[i-1] - target, B[i-1] + target].</li>
</ul>
<p>Moreover, it is just a greedy way to caluate the cost .</p>
<p>Thus, we utilize the technique 3,</p>
<h3 id="technique-3"><a href="#technique-3" class="headerlink" title="technique 3:"></a>technique 3:</h3><p><span style="color:red"><strong>If the information is unknown, adding one dimension to have dp[i][k].</strong></span></p>
<p>So, due to this technique, we redefine the state dp[i][k], where k represents the value B[i]. Since k is bounded in [0, 100]. This yields the following recurrence equation.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[i][j] = min(d[i<span class="number">-1</span>][k] + abs(j-A[i]) <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">101</span>) <span class="keyword">if</span> j- Target &lt;= k <span class="keyword">and</span> k &lt;= j + target)</span><br></pre></td></tr></table></figure>

<p>to be continued…</p>
<h2 id="Problem-2-K-Edit-Distance"><a href="#Problem-2-K-Edit-Distance" class="headerlink" title="Problem 2: K Edit Distance"></a>Problem 2: K Edit Distance</h2><p>Given Edit distance problem (modify, insert, delete), and K is max-cost, output the possible strings.</p>
<p>eg: </p>
<p>A = [“abc”, “abd”, “abcd”, “adc”], Target = “ac”, K = 1<br>Output： [“abc”, “adc”] </p>
<p>In fact, it is easy to see that this problem combines Trie and Edit distance.  We use the standard dp to solve the edit distance problem.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DP</span><span class="params">(string, target)</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="title">i</span> <span class="title">in</span> <span class="title">range</span><span class="params">(<span class="number">1</span>, len<span class="params">(string)</span>+<span class="number">1</span>)</span>:</span>    <span class="comment">#outer loop for input strings</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(target)+<span class="number">1</span>):<span class="comment">#inner loop for target string</span></span><br><span class="line">            <span class="comment">#dp process recurrence equation</span></span><br></pre></td></tr></table></figure>



<p>To employ the Trie structure,  we store all the input strings in Trie and <strong>change the outer loop to a DFS traversal procedure</strong>, which is shown as follows</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_edit_distance</span><span class="params">(A, target, k)</span>:</span></span><br><span class="line">    tree = Trie()</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> A:</span><br><span class="line">    	tree.insert(word)</span><br><span class="line">    dp = [<span class="number">0</span>] + [sys.maxsize] * len(target)</span><br><span class="line">    res = []</span><br><span class="line">    dfs(tree, target, k, dp, res)</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, target, k, pre_dp, res)</span></span></span><br><span class="line"><span class="function">	</span></span><br><span class="line">    if node.isWord and pre_dp[len(target)] &lt;= k:</span><br><span class="line">        res.append(node.string)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    dp = [sys.maxsize] * (len(target) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> node.children:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(target)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> c != target[j<span class="number">-1</span>]:</span><br><span class="line">                dp[j] = max(dp[j<span class="number">-1</span>]+<span class="number">1</span>, pre_dp[j] + <span class="number">1</span>, pre_dp[j<span class="number">-1</span>]+<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">                dp[j] = max(dp[j<span class="number">-1</span>]+<span class="number">1</span>, pre_dp[j] + <span class="number">1</span>, pre_dp[j<span class="number">-1</span>])</span><br><span class="line">        dfs(node.children[c], target, k, dp, res)</span><br></pre></td></tr></table></figure>


































      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/07/Disjoint-Set/" rel="next" title="Disjoint Set">
                <i class="fa fa-chevron-left"></i> Disjoint Set
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/09/Trie/" rel="prev" title="Trie">
                Trie <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Void Spirit</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
                <a href="/archives">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Knapsack-Problems"><span class="nav-text">Knapsack Problems</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-1-Basic-Version"><span class="nav-text">Problem 1: Basic Version</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-2-General-Version"><span class="nav-text">Problem 2: General Version</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-3-Unbounded-Version"><span class="nav-text">Problem 3: Unbounded Version</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Method-1"><span class="nav-text">Method 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method-2"><span class="nav-text">Method 2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-4-Combination-Version"><span class="nav-text">Problem 4: Combination Version</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-5-Unbounded-Combination-Version"><span class="nav-text">Problem 5: Unbounded Combination Version</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-6-Unbounded-Permutation-Version"><span class="nav-text">Problem 6: Unbounded Permutation Version</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thoughts-on-the-Knapsack-Problem"><span class="nav-text">Thoughts on the Knapsack Problem</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Partitioned-DP"><span class="nav-text">Partitioned DP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-1-Palindrome-Partitioning"><span class="nav-text">Problem 1: Palindrome Partitioning</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-2-Copy-Books"><span class="nav-text">Problem 2: Copy Books</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Interval-DP"><span class="nav-text">Interval DP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-1-Balloon-Burst"><span class="nav-text">Problem 1: Balloon Burst</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Game-Theory-DP"><span class="nav-text">Game Theory DP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-1-Stone-III"><span class="nav-text">Problem 1: Stone III</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Double-Sequence-DP"><span class="nav-text">Double Sequence DP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-1-Edit-Distance"><span class="nav-text">Problem 1: Edit Distance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-2-Longest-Increasing-Common-Subsequence"><span class="nav-text">Problem 2: Longest Increasing Common Subsequence</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#technique-1"><span class="nav-text">technique 1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#technique-2"><span class="nav-text">technique 2:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hard-Problems"><span class="nav-text">Hard Problems</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-1-Minimum-Adjustment-Cost"><span class="nav-text">Problem 1: Minimum Adjustment Cost</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#technique-3"><span class="nav-text">technique 3:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Problem-2-K-Edit-Distance"><span class="nav-text">Problem 2: K Edit Distance</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Void Spirit</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

<script src="<%- config.root %>js/hexo_resize_image.js"></script>
</body>
</html>

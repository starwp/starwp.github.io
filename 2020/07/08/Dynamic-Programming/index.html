

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Void Spirit">
  <meta name="keywords" content="">
  <title>Dynamic Programming - Make It Happen</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Algs</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://rmt.dogedoge.com/fetch/fluid/storage/post.png?w=1280&fmt=webp') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-07-08 21:38" pubdate>
        2020年7月8日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      109
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Dynamic Programming</h1>
            
            <div class="markdown-body" id="post-body">
              <blockquote>
<p>Present types of DP problems and the techniques.</p>
</blockquote>
<h1 id="Knapsack-Problems"><a href="#Knapsack-Problems" class="headerlink" title="Knapsack Problems"></a>Knapsack Problems</h1><p>The following discussion focus on the series of knapsack problems.</p>
<h2 id="Problem-1-Basic-Version"><a href="#Problem-1-Basic-Version" class="headerlink" title="Problem 1: Basic Version"></a>Problem 1: Basic Version</h2><p>Given <code>n</code> items with size <code>Ai</code>, an integer <code>m</code> denotes the size of a backpack, find the maximum size we can fit.</p>
<p>问题：n个物品不同的size，一个大小m的背包，求背包能装的最大size。</p>
<p>分析：</p>
<ol>
<li>目标很明确，使用n个物品装大小为m背包的最大size</li>
<li>每个物品状态也很明确，每个物品可选，可不选</li>
</ol>
<p>因此，直接定义dp[n]为使用前n个物品求出的最大size，再根据<strong>最后一步原理</strong>倒退分析dp[n]和dp[n-1]的联系。</p>
<pre><code class="hljs python"><span class="hljs-comment">#condition 1: if nth item cannot be selected</span>
<span class="hljs-keyword">if</span> A[n<span class="hljs-number">-1</span>] &gt; current remaining volume:
	dp[n] = dp[n<span class="hljs-number">-1</span>] 
<span class="hljs-keyword">else</span>:
<span class="hljs-comment">#condition 2: if nth item can be selected</span>
	dp[n] = dp[n<span class="hljs-number">-1</span>] + A[n<span class="hljs-number">-1</span>]</code></pre>

<p>   显然，我们发现，根据物品的状态无法直接显出有效的递归公式，因为我们少了一个背包当前的状态，于是我们补上当前背包状态，重新定于dp[n][m]</p>
<p>dp[n][m]表示使用前n个物品装大小为m背包求出最大的size，于是递推公式如下</p>
<pre><code class="hljs python"><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(m):
    <span class="hljs-comment">#condition 1: if nth item cannot be selected</span>
    <span class="hljs-keyword">if</span> A[n<span class="hljs-number">-1</span>] &gt; j: 
		dp[n][j] = dp[n<span class="hljs-number">-1</span>][j] 
	<span class="hljs-keyword">else</span>:
	<span class="hljs-comment">#condition 2: if nth item can be selected</span>
		dp[n][j] = max(dp[n<span class="hljs-number">-1</span>][j], dp[n<span class="hljs-number">-1</span>][j-A[n<span class="hljs-number">-1</span>]] + A[n<span class="hljs-number">-1</span>])</code></pre>



<p>一般来说，我们使用<strong>最后一步原理</strong>，</p>
<ul>
<li>考虑如何最后一步实现目标。</li>
</ul>
<p>对于上面这个题来说，实现最后一步的目标方式，一定是最后一个物品选，还是不选，所以，最后代码的实现，loop物品一定外循环，loop背包size一定是内循环。</p>
<p align="center">
  <img width="400" src="image-20200721180707241.png" srcset="/img/loading.gif">
</p>





<p>Then, the code is shown</p>
<pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">knapsack_I</span><span class="hljs-params">(A, m)</span>:</span>
    dp = collections.defaultdict(int)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(A)):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(m + <span class="hljs-number">1</span>):
            dp[i%<span class="hljs-number">2</span>,j] = dp[(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>,j]
            <span class="hljs-keyword">if</span> j &gt;= A[i]: 
                dp[i%<span class="hljs-number">2</span>,j] = max(dp[i%<span class="hljs-number">2</span>,j], dp[(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>,j-A[i]] + A[i])
    <span class="hljs-keyword">return</span> dp[(len(A)<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>, m]</code></pre>

<ul>
<li>Notice背包大小范围在[0,m]建立内循环。我们使用二维dp节省空间。</li>
</ul>
<h2 id="Problem-2-General-Version"><a href="#Problem-2-General-Version" class="headerlink" title="Problem 2: General Version"></a>Problem 2: General Version</h2><p>Given <code>n</code> items and a backpack with size <code>m</code>. Given array <code>A</code> representing the size of each item and array <code>V</code> representing the value of each item. What’s the maximum value can you put into the backpack?</p>
<p>问题：n物品有大小和价值，使用m大小的背包装最多的价值。</p>
<p>题解同上。</p>
<p>This one is similar to the basic version.</p>
<pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">knapsack_II</span><span class="hljs-params">(A, V, m)</span>:</span>        
    dp = [[<span class="hljs-number">0</span>] * (m + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>)] 
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(A)):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):
            dp[i%<span class="hljs-number">2</span>][j] = dp[(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>][j]
            <span class="hljs-keyword">if</span> j &gt;= A[i]:
                dp[i%<span class="hljs-number">2</span>][j] = max(dp[i%<span class="hljs-number">2</span>][j], dp[(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>][j-A[i]] + V[i])
    <span class="hljs-keyword">return</span> dp[(len(A)<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>][m]</code></pre>



<h2 id="Problem-3-Unbounded-Version"><a href="#Problem-3-Unbounded-Version" class="headerlink" title="Problem 3: Unbounded Version"></a>Problem 3: Unbounded Version</h2><p>Given <code>n</code> items and a backpack with size <code>m</code>. Given array <code>A</code> representing the size of each item and array <code>V</code> representing the value of each item. What’s the maximum value can you put into the backpack? (Each item has infinite number available)</p>
<p>问题：n物品有大小和价值，使用m大小的背包装最多的价值。物品可重复使用。</p>
<p>分析：根据最后一步构成原理，nth物品，不选，选1次，选2次，。。。无数次。</p>
<p>如果还是使用之前的定义dp[i][j]为使用前ith物品装背包j的最大价值，寻找其和i-1物品的关系</p>
<ul>
<li><p>condition 1: if nth item cannot be selected<br><code>dp[i][j] = dp[i-1][j] if nums[i] &gt; j</code> </p>
</li>
<li><p>condition 2: if nth item can be selected once<br><code>dp[i][j] = dp[i-1][j-A[i]] + V[i] if nums[i] &lt;= j</code></p>
</li>
<li><p>others:</p>
<p><code>dp[i][j] = dp[i-1][j-2*A[i]] + 2*V[i] if 2*nums[i] &lt;= j</code></p>
<p><code>dp[i][j] = dp[i-1][j-k*A[i]] + k*V[i] if k*nums[j] &lt;= j</code></p>
</li>
</ul>
<p>综上总结(包括，不选，选1次，选2次。。。。无数次) </p>
<pre><code class="hljs python"><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(sys.maxsize):
    <span class="hljs-keyword">if</span> k*A[j] &lt;= j:
    	dp[i][j] = max(dp[i][j], dp[i<span class="hljs-number">-1</span>][j-k*A[i]] + k*V[i])
    <span class="hljs-keyword">else</span>:
    	<span class="hljs-keyword">break</span></code></pre>

<p>可以看出来，多了一个for loop循环选择次数，但是重写递推(使用largeNumber次和largeNumber+1次)</p>
<p><code>dp[i][j] = max(dp[i-1][j-k*A[i]] + k*V[i] for k in range(largeNumber))</code><br><code>dp[i][j-A[i]] = max(dp[i-1][j-A[i]-k*A[i]] + k*V[i] for k in range(largeNumber))</code><br><code>dp[i][j-A[i]] = max(dp[i-1][j-(k+1)*A[i]] + k*V[i] for k in range(largeNumber))</code><br><code>dp[i][j] = max(dp[i-1][j], max(dp[i-1][j-(k+1)*A[i]] + k*V[i] for k in range(1, largeNumber)) + V[i])</code><br><code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-(k+1)*A[i]] + (k+1)*V[i] for k in range(1, largeNumber))</code></p>
<p>可得：</p>
<p><code>dp[i][j] = max(dp[i-1][j], dp[i][j-A[i]]+V[i])</code></p>
<p>其对应的物理含义，dp[i][j-A[i]] 当前第ith物品被选中的时候，因此</p>
<p><code>前i物品装背包j最大价值   =  max(第ith不选的背包j,    第ith被选中了很多次的背包j-A[i])</code></p>
<p><code>dp[i][j]             =   max(dp[i-1][j],     dp[i][j-A[i]]+V[i])</code></p>
<p align="center">
  <img width="400" src="image-20200721180235085.png" srcset="/img/loading.gif">
</p>



<p>Thus, the code is shown as </p>
<pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">knapsack_III</span><span class="hljs-params">(A, V, m)</span>:</span>
    dp = [<span class="hljs-number">0</span>] * (m + <span class="hljs-number">1</span>)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(A)):
        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> range(m+<span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> w &gt;= A[i]:
                dp[w] = max(dp[w], dp[w-A[i]] + V[i])
    <span class="hljs-keyword">return</span> dp[m]</code></pre>





<h2 id="Problem-4-Combination-Version"><a href="#Problem-4-Combination-Version" class="headerlink" title="Problem 4: Combination Version"></a>Problem 4: Combination Version</h2><p>Given n items with size <code>A[i]</code> which an integer array and all positive numbers. An integer <code>target</code> denotes the size of a backpack. Find the number of possible fill the backpack. Each item may only be used once.</p>
<p>问题：n个物品各有大小，背包大小为target，求出装满当前背包在组合数量。每个物品用一次。</p>
<p>分析：根据<strong>最后一步原理</strong>，最后一个物品装包，还是不装包的组合数为状态可以定义当前dp[i][j]，使用前i个物品装满背包大小j的组合数。有以下递推公式</p>
<pre><code class="hljs python">dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j-A[i]]</code></pre>









<p>As we consider the number of solutions in this problem, so the recurrence equation becomes</p>
<pre><code class="hljs python">dp[i][w] = dp[i<span class="hljs-number">-1</span>][w] + dp[i<span class="hljs-number">-1</span>][w-A[i]] <span class="hljs-comment"># w &gt;= A[i]</span></code></pre>

<p>where the defintion dp[i][w] represents that <strong>the number of ways obtained by using the first i items to achieve the given target w</strong>. Therefore, the code is shown as</p>
<pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">knapsack_IV</span><span class="hljs-params">(A, target)</span>        </span>
<span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-title">sum</span><span class="hljs-params">(A)</span> &lt; <span class="hljs-title">target</span>:</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    dp = [[<span class="hljs-number">0</span>] * (target + <span class="hljs-number">1</span>), [<span class="hljs-number">1</span>] + [<span class="hljs-number">0</span>] * target]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(A)):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(target + <span class="hljs-number">1</span>):
            dp[i%<span class="hljs-number">2</span>][j] = dp[(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>][j]
            <span class="hljs-keyword">if</span> j &gt;= A[i]:
                dp[i%<span class="hljs-number">2</span>][j] += dp[(i<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>][j-A[i]]  
    <span class="hljs-keyword">return</span> dp[(len(A)<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>][target]</code></pre>

<ul>
<li>Notice that the initial condition for this problem is that </li>
</ul>
<pre><code class="hljs python">dp[<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span> <span class="hljs-comment"># initial condition</span></code></pre>

<p>This means using no items to obtain the target 0 is exactly one possible way.</p>
<h2 id="Problem-5-Unbounded-Combination-Version"><a href="#Problem-5-Unbounded-Combination-Version" class="headerlink" title="Problem 5: Unbounded Combination Version"></a>Problem 5: Unbounded Combination Version</h2><p>Given an integer array <code>A</code> which contains <code>n</code> unique positive numbers, <code>A[i]</code> indicate the size of <code>i</code>th item. An integer <code>target</code> denotes the size of backpack. Find the number of ways to fill the backpack. Each item may be chosen unlimited number of times. </p>
<p>问题：n个物品各有大小，背包大小为target，求出装满当前背包在组合数量。每个物品用无数次。</p>
<p>分析：根据之前的问题3的分析，依然可以直接定义dp[i][j]为前i物品装满背包j的组合数量，递归公式如下：</p>
<pre><code class="hljs markdown">dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>] = dp[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">j</span>] + dp[<span class="hljs-string">i</span>][<span class="hljs-symbol">j-A[i</span>]]</code></pre>



<p>Thus, the code is shown as</p>
<pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">knapsack_V</span><span class="hljs-params">(A, target)</span>:</span>
    dp = [<span class="hljs-number">1</span>] + [<span class="hljs-number">0</span>] * target
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(A)):
        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> range(target + <span class="hljs-number">1</span>):
        	<span class="hljs-keyword">if</span> w &gt;= A[i]:
            	dp[w] += dp[w-A[i]]
    <span class="hljs-keyword">return</span> dp[target]</code></pre>





<h2 id="Problem-6-Unbounded-Permutation-Version"><a href="#Problem-6-Unbounded-Permutation-Version" class="headerlink" title="Problem 6: Unbounded Permutation Version"></a>Problem 6: Unbounded Permutation Version</h2><p>Given an integer array <code>A</code> with all positive numbers and no duplicates, find the number of permutations that add up to a positve integer target. </p>
<p>eg. A=[1, 2, 4], target = 4. The solution [1,2,1] and [2,1,1] are considered different.</p>
<p>问题：n个物品各有unique大小，背包大小为target，求出装满当前背包在排列数量。每个物品用无数次。</p>
<p>分析：根据最后一步构成原理，构成最后一步的permutation可以来自于数组中任何一个物品。因此只能定义dp[target]为目标，递归公式为：</p>
<pre><code class="hljs python">dp[t] = sum([dp[t-A[i]] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(A)) <span class="hljs-keyword">if</span> t&gt;=A[i]])</code></pre>

<p>这样就类似爬楼梯。</p>
<p align="center">
  <img width="400" src="image-20200721183427683.png" srcset="/img/loading.gif">
</p>



<p>Thus, the code is shown as</p>
<pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">knapsack_VI</span><span class="hljs-params">(A, target)</span>:</span>
    dp = [<span class="hljs-number">1</span>] + [<span class="hljs-number">0</span>] * target
	<span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span> + target):
		<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(A)):
			<span class="hljs-keyword">if</span> w &gt;= A[i]:
				dp[w] += dp[w-A[i]]
	<span class="hljs-keyword">return</span> dp[target]</code></pre>









<h2 id="Thoughts-on-the-Knapsack-Problem"><a href="#Thoughts-on-the-Knapsack-Problem" class="headerlink" title="Thoughts on the Knapsack Problem"></a>Thoughts on the Knapsack Problem</h2><p>Today, I did the target sum problem, where I learned two ways to solve the problem.</p>
<ol>
<li>Pull: </li>
</ol>
<pre><code class="hljs python">dp[i][sum] = dp[i<span class="hljs-number">-1</span>][sum - A[i]] + dp[i<span class="hljs-number">-1</span>][sum + A[i]]</code></pre>



<ol start="2">
<li>Push:</li>
</ol>
<pre><code class="hljs python">dp[i][sum + A[i]] += dp[i][sum]
dp[i][sum - A[i]] += dp[i][sum]</code></pre>



<p>It is interesting to use push to solve the problem. In addition, we can use the dictionary to lower the search space in the initial stages.</p>
<pre><code class="hljs python"><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> A:
    tmp = collections.defaultdict(int)
    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dp:
        tmp[key + e] += dp[key]
        tmp[key - e] += dp[key]
    dp = tmp
<span class="hljs-keyword">return</span> dp[target]</code></pre>



<p>However, more interesting thing is that we don’t need to do the minus part by considering the following reduction. As it holds that </p>
<p>P - N = Target</p>
<p>P - N + P + N = Target + Sum(A)</p>
<p>P = (T + Sum) / 2</p>
<p>where P is a set of positive integers and N is the set of negative integers. </p>
<p>So the problem can be transformed to a subset sum problem to find a target sum at (T + Sum) / 2, by using this condition, we further pruning the search. </p>
<h1 id="Partitioned-DP"><a href="#Partitioned-DP" class="headerlink" title="Partitioned DP"></a>Partitioned DP</h1><p>This partitioned DP 处理string和sequence， 且我们需要将stringparitition成k段substrings (subsequence) ，每段满足不同的条件.</p>
<h2 id="Problem-1-Palindrome-Partitioning"><a href="#Problem-1-Palindrome-Partitioning" class="headerlink" title="Problem 1: Palindrome Partitioning"></a>Problem 1: Palindrome Partitioning</h2><p>Given a string <code>s</code>, cut <code>s</code> into some substrings such that every substring is a palindrome. Return the <strong>minimum</strong> cuts needed for a palindrome partitioning of <em>s</em>.</p>
<p>Based on the last step principle, we can define dp[i] as the min-cut obtained by the string with the first i elements. Therefore, we could have the recurrence</p>
<pre><code class="hljs python">dp[i] = min(dp[i], dp[j] + <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> isPalindrome(s[i:j+<span class="hljs-number">1</span>]))</code></pre>

<p>This indicates that we need to store the result of that whether every string s[i:j+1] is a palindrome or not. Then, we need O(n^2) space. </p>
<p>To shrink the space complexity, a good technique is to apply <strong>push</strong>, then we can decide if a substring is a palindrome and store its results while updating the dp values. Thus, the push technique shows the recurrence as follows </p>
<pre><code class="hljs python">dp[i+r] = min(dp[i+r], dp[i-r<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
dp[i+r+<span class="hljs-number">1</span>] = min(dp[i+r+<span class="hljs-number">1</span>], dp[i-r<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>) <span class="hljs-comment"># one is for odd palindrome, another is for even case</span></code></pre>

<p>where r represents the “radius” of the substring s[i-r, i+r].</p>
<h2 id="Problem-2-Copy-Books"><a href="#Problem-2-Copy-Books" class="headerlink" title="Problem 2: Copy Books"></a>Problem 2: Copy Books</h2><p>Given <code>n</code> books and the <code>i-th</code> book has <code>pages[i]</code> pages. There are <code>k</code> persons to copy these books. These books list in a row and each person can claim a continous range of books. For example, one copier can copy the books from <code>i-th</code> to <code>j-th</code> continously, but he can not copy the 1st book, 2nd book and 4th book (without 3rd book). They start copying books at the same time and they all cost 1 minute to copy 1 page of a book. What’s the best strategy to assign books so that the slowest copier can finish at earliest time? Return the shortest time that the slowest copier spends.</p>
<p>问题：n本书不同的页数，k个人负责抄书，每个人只能连续的抄书，求k个人中最慢的那个抄书的会花的最短的时间</p>
<p>分析：根据min max(f[0], f[1], f[2],…,f[k-1])，根据最后一步原理，假设最后一个人抄书的范围设定在[j,n-1]本，设dp[i][j]为前i人且第i人抄到第j本的最短时间，可得如下递归式子 </p>
<pre><code class="hljs python"><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(j):
	dp[i][j] = min(dp[i][j], max(dp[i<span class="hljs-number">-1</span>][k] , sum(pages[k+<span class="hljs-number">1</span>:j+<span class="hljs-number">1</span>])))</code></pre>











<p>Given this partitioned one, we can use the previously similar last step principle.</p>
<pre><code class="hljs python">dp[k][i] = min(max(dp[k<span class="hljs-number">-1</span>][j], sum(pages[j:i]) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i))</code></pre>

<p>where dp[i] as the shortest time using by k workers with the first i books.</p>
<p>The abve recurrence equation also requires to deal with the summation in advance to lower the time complexity.</p>
<ul>
<li>Notice that sometimes based on the last step princeple, we might need to do additional computation to do the comparing, which probably could be done in advance and stored the results to lower the time complexity. <span style="color:red"><strong>(extra computation, comparing, do it ahead to store them)</strong></span>. </li>
</ul>
<h1 id="Interval-DP"><a href="#Interval-DP" class="headerlink" title="Interval DP"></a>Interval DP</h1><p>区间问题应该是最难的DP问题，不同于传统的DP问题，使用最后一步构成原理， 通常无法实现polynomial time的求解，因此，当我们使用最后一步无法求解的时候，我们需要考虑区间DP的特性，这就意味着将问题切割成更小的问题切用2D的方式表示，例如dp[i][j]，表示问题在区间[i,j]的解.</p>
<p>To be specific, the last step principle uses dp[i] with 1D index, where i is the last step. However, the interval dp typically uses dp[i][j] with 2D index, where i is the first step and j is the last step. It is kind of like divide and conquer. <span style="color:red"><strong>(2D index, dp[start][end])</strong></span>. </p>
<h2 id="Problem-1-Balloon-Burst"><a href="#Problem-1-Balloon-Burst" class="headerlink" title="Problem 1: Balloon Burst"></a>Problem 1: Balloon Burst</h2><p> Given <code>n</code> balloons, indexed from <code>0</code> to <code>n-1</code>. Each balloon is painted with a number on it represented by array <code>nums</code>. You are asked to burst all the balloons. If the you burst balloon <code>i</code> you will get <code>nums[left] * nums[i] * nums[right]</code> coins. Here <code>left</code> and <code>right</code> are adjacent indices of <code>i</code>. After the burst, the <code>left</code> and <code>right</code> then becomes adjacent.</p>
<p>Find the maximum coins you can collect by bursting the balloons wisely.</p>
<p><strong>Note:</strong></p>
<ul>
<li>You may imagine <code>nums[-1] = nums[n] = 1</code>. They are not real therefore you can not burst them.</li>
</ul>
<p>分析：扎气球实际上permutation的问题，因此，最后一步构成原理可以由每个气球构成(n个中)。因此，定义dp[0][n-1]为使用第0-n-1个气球的cost，那么可得</p>
<pre><code class="hljs python">dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>] = max(dp[<span class="hljs-number">0</span>][i]+nums[<span class="hljs-number">0</span>]*nums[i]*nums[n<span class="hljs-number">-1</span>]+dp[i][n<span class="hljs-number">-1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n<span class="hljs-number">-2</span>))</code></pre>

<p>由此，我们将问题切割为更小的区别子问题，代码如下：</p>
<pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ballonn</span><span class="hljs-params">(A)</span>:</span>
    A.insert(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
    A.append(<span class="hljs-number">1</span>)
    n = len(A)
    dp = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n)] 
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>, n):
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>,j):
                dp[i][j] = max(dp[i][j], dp[i][k]+A[i]*A[k]*A[j]+dp[k][j])
	<span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]</code></pre>



<p>注意：消去型的题目，逆向考虑最后一步，答案如何得到。</p>
<h1 id="Game-Theory-DP"><a href="#Game-Theory-DP" class="headerlink" title="Game Theory DP"></a>Game Theory DP</h1><p> The geme theory dp problem deals with two playes with the optimal policy. So, we generally need to consider the two players together and solve the recurrence in a reversed manner.</p>
<p>博弈DP的特点是两个选手always采用最优策略。</p>
<h2 id="Problem-1-Coins-in-a-line"><a href="#Problem-1-Coins-in-a-line" class="headerlink" title="Problem 1: Coins in a line"></a>Problem 1: Coins in a line</h2><p>问题：有一排N个石子，Alice, Bob两人轮流取石子。每次一个人可以从最右边取走1个或2个石子。取走最后石子的人胜。 问先手Alice是否必胜 (先手必胜: true,先手必败: false)  </p>
<p>分析：博弈问题并不适合最后一步分析，因为是面临一个setting，所以一般来说，使用第一步分析，而我们要确认的是dp[0]的值，表示当前还剩下多少n个没有取走。有点逆向的感觉，那么可以显然看出，dp[n-1]和dp[n-2]一定是True。</p>
<p>博弈的递归关系可以对之前的状态取反写出来(<strong>最好举例确认逻辑关系</strong>)</p>
<pre><code class="hljs inform7">dp<span class="hljs-comment">[i]</span> |= not(dp<span class="hljs-comment">[i+1]</span> and dp<span class="hljs-comment">[i+2]</span>)</code></pre>

<p>因此代码如下：</p>
<pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coin</span><span class="hljs-params">(n)</span>:</span>
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    dp = [<span class="hljs-literal">False</span>]*(n<span class="hljs-number">-2</span>) + [<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>] 
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n<span class="hljs-number">-3</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>):
        dp[i] = <span class="hljs-keyword">not</span>(dp[i+<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> dp[i+<span class="hljs-number">2</span>])
    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>]</code></pre>



<h2 id="Problem-2-Coins-in-a-line-II"><a href="#Problem-2-Coins-in-a-line-II" class="headerlink" title="Problem 2: Coins in a line II"></a>Problem 2: Coins in a line II</h2><p>问题：There are n coins with different value in a line. Two players take turns to take one or two coins from <strong>left side</strong> until there are no more coins left. The player who take the coins with the most value wins.</p>
<p>分析：利用下一题的原理可以求解，</p>
<h2 id="Problem-3-Coins-in-a-line-III"><a href="#Problem-3-Coins-in-a-line-III" class="headerlink" title="Problem 3: Coins in a line III"></a>Problem 3: Coins in a line III</h2><p>题意：给定一个序列a[0], a[1], …, a[N-1]，两个玩家Alice和Bob轮流取数，每个人每次只能取第一个数或最后一个数， 双方都用最优策略，使得自己的数字和尽量比对手大，问先手是否必胜。如果数字和一样，也算先手胜。  </p>
<p>分析：利用第一步分析，且因为是博弈关系，我们考虑dp[0:n-1]不是算当前选手最大值，而是当前选手比对手多的值。递归关系有</p>
<pre><code class="hljs python">dp[<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>] = max(A[<span class="hljs-number">0</span>]-dp[<span class="hljs-number">1</span>，n<span class="hljs-number">-1</span>], A[n<span class="hljs-number">-1</span>]-dp[<span class="hljs-number">0</span>，n<span class="hljs-number">-2</span>]) <span class="hljs-comment">#Alice比bob多的值</span>
dp[<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>]，dp[<span class="hljs-number">0</span>，n<span class="hljs-number">-2</span>] 是bob比alice多的值</code></pre>

<p>这样代码如下：</p>
<pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conins</span><span class="hljs-params">(a)</span>:</span>
    n = len(a)
    dp = [[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n)]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i, n<span class="hljs-number">-1</span>):
            <span class="hljs-keyword">if</span> i == j:
                dp[i][j] = a[i]
            <span class="hljs-keyword">else</span>:
            	dp[i][j] = max(a[i]-dp[i+<span class="hljs-number">1</span>，j], a[j]-dp[i，j<span class="hljs-number">-1</span>])
    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>] &gt;= <span class="hljs-number">0</span></code></pre>

<p>例子分析：</p>
<pre><code class="hljs python">输入： [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">233</span>, <span class="hljs-number">7</span>]
输出： <span class="hljs-literal">True</span> （先手取走<span class="hljs-number">1</span>，无论后手取哪个，先手都能取走<span class="hljs-number">233</span>）

<span class="hljs-number">1</span>: dp[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">7</span>
    
<span class="hljs-number">2</span>: dp[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">233</span>, dp[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = max(<span class="hljs-number">233</span>-dp[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>], <span class="hljs-number">7</span>-dp[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]) = <span class="hljs-number">226</span>

<span class="hljs-number">3</span>: dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>,   dp[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = max( <span class="hljs-number">5</span>-dp[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], <span class="hljs-number">233</span>-dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) = <span class="hljs-number">228</span>, dp[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = max(<span class="hljs-number">5</span>-dp[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-number">7</span>-dp[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]) = <span class="hljs-number">-221</span> 

<span class="hljs-number">4</span>: dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>,   dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = max(<span class="hljs-number">1</span>-dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], <span class="hljs-number">5</span>-dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]) = <span class="hljs-number">4</span>, dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = max(<span class="hljs-number">1</span><span class="hljs-number">-288</span>,<span class="hljs-number">233</span><span class="hljs-number">-4</span>)=<span class="hljs-number">229</span>, dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]=max(<span class="hljs-number">1</span>+<span class="hljs-number">221</span>,<span class="hljs-number">7</span><span class="hljs-number">-229</span>)=<span class="hljs-number">222</span></code></pre>











<h1 id="Double-Sequence-DP"><a href="#Double-Sequence-DP" class="headerlink" title="Double Sequence DP"></a>Double Sequence DP</h1><p>双序列DP问题一般的目标是基于两个串的特性的。例如，考虑一个问题P，有两个串A和B目标是(最大公共字串，将A变成B)。因此，根据最后一步原理，一般我们定义dp[i][j]表示目标去求解问题。</p>
<p>为了找到递推方程，一般利用pull的方法。首先，最重要的一点，假设前i个A和前j个B的<strong>子问题的目标</strong>已经实现，例如dp[i][j]对应的min/max值求出来了，也就是说对应的dp[i][j]的目标配置被完全实现。例如，最长公共子串问题，dp[i][j]不仅代表这个最长的值，也代表着A串已经完全转化到B了。基于这个目标，我们就需要反向推理如何获得dp[i][j]，有哪些可能的最后一步实现这个目标和配置。一般来说，相关的变量是dp[i-1][j]，dp[i][j-1]，dp[i-1][j-1]。</p>
<p>另一个很重要的点是，即使我们考虑了dp[i][j]的目标配置，当处理实际的 问题，例如(处理，原始A[0:i] and B[0:j] 需要改变配置到A&#39;[0:x], B&#39;[0:y]基于目标，但是我们的递推方程在建立的时候，还是需要考虑原始的string和index，以及其处理的orignial strings and index <span style="color:red"><strong>(A[i-1], B[j-1]), (A[i], B[j-1]), (A[i],B[j-1])</strong></span> rather than those settings ((A&#39;[0:x-1], B&#39;[0:y-1]), A&#39;[0:x], B&#39;[0:y-1]). </p>
<h2 id="Problem-1-Distinct-Subsequences"><a href="#Problem-1-Distinct-Subsequences" class="headerlink" title="Problem 1: Distinct Subsequences"></a>Problem 1: Distinct Subsequences</h2><p>题意：给定两个字符串<code>A[0..m-1]</code>，<code>B[0..n-1]</code>，问B在A中出现多少次（可以不连续）</p>
<pre><code class="hljs python">例子
• 输入：A=“rabbbit”, B=“rabbit”
• 输出：<span class="hljs-number">3</span>
– rabbbit
– rabbbit
– rabbbit</code></pre>



<p>分析：之所以分析不出来，</p>
<ul>
<li>问题1：求多少种的时候，是＋，最后一步分类，再讨论分类用加号链接</li>
</ul>
<h2 id="Problem-2-Edit-Distance"><a href="#Problem-2-Edit-Distance" class="headerlink" title="Problem 2: Edit Distance"></a>Problem 2: Edit Distance</h2><p>Given two words <code>A</code> and <code>B</code>, find the minimum number of steps required to convert <code>A</code> to <code>B</code>. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word:</p>
<ul>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ul>
<p>问题：编辑距离：</p>
<p>Since the conversion requires the permutation, we can define that dp[i][j] is the min step that we convert A[i] to B[j]. Based on the discussion above, by reasoning backward, the possible step to achieve the conversion is to either insert at pos i, delete the pos i, or replace the pos i. Hence, the recurrence equation is derivated as </p>
<pre><code class="hljs python">dp[i][j] = min(dp[i][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>,  \ <span class="hljs-comment"># insert after pos i  </span>
               dp[i<span class="hljs-number">-1</span>][j] + <span class="hljs-number">1</span>,  \ <span class="hljs-comment"># delete the pos i</span>
               dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>,\ <span class="hljs-comment"># replace the pos i</span>
			   dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])\ <span class="hljs-comment"># no operation A[i] = B[j]</span></code></pre>

<p>where the above cases are discussed:</p>
<ul>
<li>Case 1: inserting at pos i indicates in the problem dp[i][j] the new element insert after A[i] matches B[j], so that 1st recurrence holds. </li>
<li>Case 2: deleting at pos i indicates in the problem dp[i][j] A[i] is extra element and takes the extra step, so 2nd case holds</li>
<li>Case 3: replacing, easily understood</li>
<li>Case 4: no operation, easily understood. </li>
</ul>
<h2 id="Problem-3-Longest-Increasing-Common-Subsequence"><a href="#Problem-3-Longest-Increasing-Common-Subsequence" class="headerlink" title="Problem 3: Longest Increasing Common Subsequence"></a>Problem 3: Longest Increasing Common Subsequence</h2><p>Given 2 sequences of integers, we need to find a longest sub-sequence which is common to both the sequences, and the numbers of such a sub-sequence are in strictly increasing order.</p>
<p>Let dp[i][j] be the LICS of A[0:i] and B[0:j]. Based on the last step principle, consider the following cases:</p>
<ul>
<li>Case 1: B[j-1] is not in LICS, dp[i][j] = dp[i][j-1]</li>
<li>Case 2: A[i-1] is not in the LICS, dp[i][j] = dp[i-1][j]</li>
<li>Case 3: A[i-1] and B[j-1] are both in LICS, dp[i][j] = dp[i-1][j-1] + 1, where A[i-1] = B[j-1] and A[i-1] is larger than the last value in the setting of dp[i-1][j-1]. (missing some cases…)</li>
</ul>
<p>Notice that the difficulty in Case 3 is that we need to know the last value in the previous setting dp[i-1][j-1], which is in fact unknown. To solve the problem, I use the following technique 1. </p>
<h3 id="technique-1"><a href="#technique-1" class="headerlink" title="technique 1:"></a>technique 1:</h3><p><span style="color:red"><strong>If the information is unknown, compute it by introducing dp[i][j][1].</strong></span></p>
<p>Based on the technique, we extend the definition dp[i][j] to target both the maximal length LICS and the smallest ending number in the LICS.</p>
<ul>
<li>dp[i][j][0]: maximal length of LICS</li>
<li>dp[i][j][1]: smallest ending number of this LICS</li>
</ul>
<p>Thus, we go back to previous discussion.</p>
<ul>
<li>Case 1: dp[i][j][0] = dp[i][j-1][0], dp[i][j][1] = dp[i][j-1][1]</li>
<li>Case 2: dp[i][j][0] = dp[i-1][j][0], dp[i][j][1] = dp[i-1][j][1] </li>
<li>Case 3: dp[i][j][0] = dp[i-1][j-1][0] + 1 if A[i-1] = B[j-1] and A[i-1] &gt; dp[i-1][j-1][1], dp[i][j][1] = A[i-1]</li>
</ul>
<p>However, something is overlooked in Case 3. For A[i-1] = B[j-1], we need to update the dp[i][j] by comparing all the previously dp[i-1][0]…dp[i-1][j-1] to find the LICS, so we modify Case 3 to:</p>
<ul>
<li>Case 3: dp[i][j][0] =  max(dp[i][j][0], dp[i-1][k][0] + 1) if A[i-1] = B[j-1] and A[i-1] &gt; dp[i-1][k][1], for k in range(j-1).</li>
</ul>
<pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">LICS</span><span class="hljs-params">(A, B)</span>:</span>
    dp = collections.defaultdict(int)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(A)+<span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(B)+<span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j == <span class="hljs-number">0</span>:
                dp[i, j, <span class="hljs-number">0</span>], dp[i, j, <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, sys.maxsize
                <span class="hljs-keyword">continue</span>
                
            dp[i,j,<span class="hljs-number">1</span>] = sys.maxsize
            <span class="hljs-keyword">if</span> A[i<span class="hljs-number">-1</span>] == B[j<span class="hljs-number">-1</span>]:
                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>):
                    <span class="hljs-keyword">if</span> A[i<span class="hljs-number">-1</span>] &gt; dp[i<span class="hljs-number">-1</span>,k<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>] <span class="hljs-keyword">or</span> dp[i<span class="hljs-number">-1</span>,k<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>] == sys.maxsize <span class="hljs-keyword">and</span> \
                        dp[i,j,<span class="hljs-number">0</span>] &lt;= dp[i<span class="hljs-number">-1</span>,k<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>:
                            dp[i,j,<span class="hljs-number">1</span>], dp[i,j,<span class="hljs-number">0</span>] = A[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>,k<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>            
 
            <span class="hljs-keyword">if</span> dp[i,j,<span class="hljs-number">0</span>] &lt;= dp[i,j<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>]:
                dp[i,j,<span class="hljs-number">1</span>] = min(dp[i,j,<span class="hljs-number">1</span>], dp[i,j<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> dp[i,j,<span class="hljs-number">0</span>] == dp[i,j<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>] <span class="hljs-keyword">else</span> dp[i,j<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>] 
                dp[i,j,<span class="hljs-number">0</span>] = dp[i,j<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>]
                    
            <span class="hljs-keyword">if</span> dp[i,j,<span class="hljs-number">0</span>] &lt;= dp[i<span class="hljs-number">-1</span>,j,<span class="hljs-number">0</span>]:
                dp[i,j,<span class="hljs-number">1</span>] = min(dp[i,j,<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>,j,<span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> dp[i,j,<span class="hljs-number">0</span>] == dp[i<span class="hljs-number">-1</span>,j,<span class="hljs-number">0</span>] <span class="hljs-keyword">else</span> dp[i<span class="hljs-number">-1</span>,j,<span class="hljs-number">1</span>]
                dp[i,j,<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>,j,<span class="hljs-number">0</span>]
            
    <span class="hljs-keyword">return</span> dp[len(A), len(B), <span class="hljs-number">0</span>]</code></pre>



<p>Based on the above logic, it is a O(n^3) time algorithm. In addtion, the logic is a little complicated due to we introduce the last value in the LICS. Thus, In the following we use the 2nd technique to solve it. </p>
<h3 id="technique-2"><a href="#technique-2" class="headerlink" title="technique 2:"></a>technique 2:</h3><p><span style="color:red"><strong>If the information is unknown, associating it with the index in dp[i][j].</strong></span></p>
<p>Based on this technique, it is obvious that we need to associate the last value of LICS of the index of dp[i][j]. Therefore, we redefine dp[i][j] to be the LICS of A[0:i] and B[0:j] where B[j-1] is the last value in this LICS. Therefore, the following recurrence can be derived easily.</p>
<ul>
<li>Case 1: dp[i][j] = max(dp[i][j], dp[i-1][j] if A[i-1] != B[j-1])</li>
<li>Case 2: dp[i][j] = max(dp[i][j], dp[i-1][k] if A[i-1] == B[j-1] and B[j-1] &gt; B[k] for k in range(j))</li>
</ul>
<p>With the above recurrence equation, we are able to clearly solve the problem in O(n^3) time. However, there are some space for us to improve it. That is, since A[i-1] = B[j-1] and B[j-1] is the largest value, we need to find maximal of all the dp[i-1][k] with B[k] smaller than A[j-1],</p>
 <pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">LICS</span><span class="hljs-params">(A, B)</span>:</span>
    dp = [<span class="hljs-number">0</span>]*(len(B))
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(A)):
        max_i_minus_one = <span class="hljs-number">0</span> 
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(B)):
            <span class="hljs-keyword">if</span> A[i] == B[j]:
                dp[j] = max(dp[j], max_i_minus_one + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> A[i] &gt; B[j]:
                max_i_minus_one = max(dp[j], max_i_minus_one)
    <span class="hljs-keyword">return</span> max(dp)</code></pre>



<p>Therefore, the above algorithm is O(n^2) time with O(n) space.</p>
<h1 id="Hard-Problems"><a href="#Hard-Problems" class="headerlink" title="Hard Problems"></a>Hard Problems</h1><p>This sections presents some hard problems and discusses the important thoughts on solviing them.</p>
<h2 id="Problem-1-K-sum"><a href="#Problem-1-K-sum" class="headerlink" title="Problem 1: K sum"></a>Problem 1: K sum</h2><p>题意：给定数组A，包含n个互不相等的正整数, 问有多少种方式从中找出K个数，使得它们的和是Target  </p>
<p>分析：目标构成target，且是组合问题，根据最后一步构成原理，</p>
<p>到底是dp[i][k][target]，还是dp[i][target][k]，</p>
<pre><code class="hljs python">dp[i][k][target] = dp[i<span class="hljs-number">-1</span>][k][target] + dp[i<span class="hljs-number">-1</span>][k<span class="hljs-number">-1</span>][target-A[i]]</code></pre>

<p>代码是这样的</p>
<pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kSum</span><span class="hljs-params">(A, k, target)</span>:</span>
    dp = collections.defaultdict(int)
    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(A)+<span class="hljs-number">1</span>):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>):
            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> range(target+<span class="hljs-number">1</span>):
                <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> t == <span class="hljs-number">0</span>:
                    dp[i][j][t] = <span class="hljs-number">1</span>
                    <span class="hljs-keyword">continue</span>
                dp[i][j][t] = dp[i<span class="hljs-number">-1</span>][j][t]
                <span class="hljs-keyword">if</span> t &gt;= A[i<span class="hljs-number">-1</span>]:
                    dp[i][j][t] += dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>][t-A[i<span class="hljs-number">-1</span>]]
    <span class="hljs-keyword">return</span> dp[len(A)][k][target]</code></pre>

<p>例子：</p>
<pre><code class="hljs python">输入：A=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], K=<span class="hljs-number">2</span>, Target = <span class="hljs-number">5</span>
输出：<span class="hljs-number">2</span> (<span class="hljs-number">1</span> + <span class="hljs-number">4</span> = <span class="hljs-number">5</span>, <span class="hljs-number">2</span> + <span class="hljs-number">3</span> = <span class="hljs-number">5</span>)

dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, ..., dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>
    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0.</span>.., dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>

dp[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, dp[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, ..., dp[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>
    dp[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, dp[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, dp[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1.</span>.., dp[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>


之前自己推算dp[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>，还以为初始化错了。

输入：A=[<span class="hljs-number">1</span>], K=<span class="hljs-number">0</span>, Target=<span class="hljs-number">1</span>
输出：<span class="hljs-number">0</span>
这个例子出错了，是因为dp[i][j][t] += dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>][t-A[i<span class="hljs-number">-1</span>]]，j<span class="hljs-number">-1</span>=<span class="hljs-number">-1</span>了。(需要引起注意，python <span class="hljs-number">-1</span> index问题)</code></pre>



<p>如果是定义dp[i][target][k]，使用上面相同的代码依然正确(交换target和k的维度)。</p>
<p>但是这个解的时间复杂度太高了。其实在是否选择当前第ith number的时候，我们可以记录选择了的个数。因此考虑这个信息。可以使用push的方式编写递推关系，这样有更好的效率。</p>
<pre><code class="hljs python"><span class="hljs-comment">#依然使用dp[i][t]的定义</span>
<span class="hljs-comment">#假设最初的值dp[0][0] = 1</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kSum</span><span class="hljs-params">(A, k, target)</span>:</span>
    dp = collections.defaultdict(int)
    dp[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] = <span class="hljs-number">1</span> 
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(A)+<span class="hljs-number">1</span>):
        tmp = collections.defaultdict(int)
        <span class="hljs-keyword">for</span> j, t <span class="hljs-keyword">in</span> dp:
            <span class="hljs-keyword">if</span> j&gt;k <span class="hljs-keyword">or</span> t&gt;target: 
                <span class="hljs-keyword">continue</span>
            tmp[j,t] += dp[j,t]
            tmp[j+<span class="hljs-number">1</span>,t+A[i<span class="hljs-number">-1</span>]] += dp[j,t]
        dp=tmp
    <span class="hljs-keyword">return</span> dp[k,target]</code></pre>







<h2 id="Problem-2-Minimum-Adjustment-Cost"><a href="#Problem-2-Minimum-Adjustment-Cost" class="headerlink" title="Problem 2: Minimum Adjustment Cost"></a>Problem 2: Minimum Adjustment Cost</h2><p>To solve this problem, we start with the last step principle. We thus define dp[i] as the min-cost of adjustment for first i integers. Based on this defintion, we assume that A[i] is changed to B[i], where it holds that |B[i]- B[i-1]| &lt; target. </p>
<p>So, there are two important questions to answer. </p>
<ul>
<li>B[i-1] is unknow</li>
<li>Even it is known, how can we guarantee it is <strong>optimal</strong> to modify A[i] to B[i] within [B[i-1] - target, B[i-1] + target].</li>
</ul>
<p>Moreover, it is just a greedy way to caluate the cost .</p>
<p>Thus, we utilize the technique 3,</p>
<h3 id="technique-3"><a href="#technique-3" class="headerlink" title="technique 3:"></a>technique 3:</h3><p><span style="color:red"><strong>If the information is unknown, adding one dimension to have dp[i][k].</strong></span></p>
<p>So, due to this technique, we redefine the state dp[i][k], where k represents the value B[i]. Since k is bounded in [0, 100]. This yields the following recurrence equation.</p>
<pre><code class="hljs python">d[i][j] = min(d[i<span class="hljs-number">-1</span>][k] + abs(j-A[i]) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">101</span>) <span class="hljs-keyword">if</span> j- Target &lt;= k <span class="hljs-keyword">and</span> k &lt;= j + target)</code></pre>

<p>to be continued…</p>
<h2 id="Problem-3-K-Edit-Distance"><a href="#Problem-3-K-Edit-Distance" class="headerlink" title="Problem 3: K Edit Distance"></a>Problem 3: K Edit Distance</h2><p>Given Edit distance problem (modify, insert, delete), and K is max-cost, output the possible strings.</p>
<p>eg: </p>
<p>A = [“abc”, “abd”, “abcd”, “adc”], Target = “ac”, K = 1<br>Output： [“abc”, “adc”] </p>
<p>In fact, it is easy to see that this problem combines Trie and Edit distance.  We use the standard dp to solve the edit distance problem.</p>
<pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DP</span><span class="hljs-params">(string, target)</span></span>
<span class="hljs-function">    <span class="hljs-title">for</span> <span class="hljs-title">i</span> <span class="hljs-title">in</span> <span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-number">1</span>, len<span class="hljs-params">(string)</span>+<span class="hljs-number">1</span>)</span>:</span>    <span class="hljs-comment">#outer loop for input strings</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(target)+<span class="hljs-number">1</span>):<span class="hljs-comment">#inner loop for target string</span>
            <span class="hljs-comment">#dp process recurrence equation</span></code></pre>



<p>To employ the Trie structure,  we store all the input strings in Trie and <strong>change the outer loop to a DFS traversal procedure</strong>, which is shown as follows</p>
<pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">k_edit_distance</span><span class="hljs-params">(A, target, k)</span>:</span>
    tree = Trie()
    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> A:
    	tree.insert(word)
    dp = [<span class="hljs-number">0</span>] + [sys.maxsize] * len(target)
    res = []
    dfs(tree, target, k, dp, res)
    <span class="hljs-keyword">return</span> res 

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node, target, k, pre_dp, res)</span></span>
<span class="hljs-function">	</span>
    if node.isWord and pre_dp[len(target)] &lt;= k:
        res.append(node.string)
        <span class="hljs-keyword">return</span>
    dp = [sys.maxsize] * (len(target) + <span class="hljs-number">1</span>)
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> node.children:
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(target)+<span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> c != target[j<span class="hljs-number">-1</span>]:
                dp[j] = max(dp[j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>, pre_dp[j] + <span class="hljs-number">1</span>, pre_dp[j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>)
			<span class="hljs-keyword">else</span>:
                dp[j] = max(dp[j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>, pre_dp[j] + <span class="hljs-number">1</span>, pre_dp[j<span class="hljs-number">-1</span>])
        dfs(node.children[c], target, k, dp, res)</code></pre>


































            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/07/09/Trie/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Trie</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/07/07/Disjoint-Set/">
                        <span class="hidden-mobile">Disjoint Set</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Dynamic Programming&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>

















  

  

  

  

  

  





</body>
</html>
